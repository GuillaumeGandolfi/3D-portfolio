<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <title>Galaxy Background</title>
    <script src="https://unpkg.com/three@0.152.0/build/three.min.js"></script>
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
        background: #000;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <canvas id="threeCanvas"></canvas>
    <script>
      const canvas = document.getElementById("threeCanvas");
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      canvas.parentNode.insertBefore(renderer.domElement, canvas);

      const scene = new THREE.Scene();

      // Dégradé de fond avec un shader pour éviter les erreurs de chargement
      const gradientMaterial = new THREE.ShaderMaterial({
        uniforms: {},
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          varying vec2 vUv;
          void main() {
            vec3 topColor = vec3(0.05, 0.0, 0.1); // Bleu nuit
            vec3 bottomColor = vec3(0.0, 0.0, 0.0); // Noir profond
            gl_FragColor = vec4(mix(bottomColor, topColor, vUv.y), 1.0);
          }
        `,
        side: THREE.BackSide,
      });

      const skyGeometry = new THREE.SphereGeometry(1000, 32, 32);
      const sky = new THREE.Mesh(skyGeometry, gradientMaterial);
      scene.add(sky);

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        1,
        2000
      );
      camera.position.z = 600;

      // Création d'un champ d'étoiles avec variation de taille
      const starCount = 10000;
      const positions = new Float32Array(starCount * 3);
      const sizes = new Float32Array(starCount);

      for (let i = 0; i < starCount * 3; i += 3) {
        positions[i] = (Math.random() - 0.5) * 2000;
        positions[i + 1] = (Math.random() - 0.5) * 2000;
        positions[i + 2] = (Math.random() - 0.5) * 2000;
        sizes[i / 3] = Math.random() * 2.5 + 0.5;
      }

      const starGeometry = new THREE.BufferGeometry();
      starGeometry.setAttribute(
        "position",
        new THREE.BufferAttribute(positions, 3)
      );
      starGeometry.setAttribute("size", new THREE.BufferAttribute(sizes, 1));

      const starMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 2,
        transparent: true,
        opacity: 0.9,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
      });

      const stars = new THREE.Points(starGeometry, starMaterial);
      scene.add(stars);

      function animate() {
        requestAnimationFrame(animate);
        stars.rotation.x += 0.0002;
        stars.rotation.y += 0.0004;

        // Scintillement des étoiles
        const sizes = starGeometry.attributes.size.array;
        for (let i = 0; i < sizes.length; i++) {
          // Variation de la taille
          sizes[i] += (Math.random() - 0.5) * 0.05;
          // Empêche des tailles trop grandes/petites
          sizes[i] = Math.max(0.5, Math.min(3, sizes[i]));
        }
        starGeometry.attributes.size.needsUpdate = true;

        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      });
    </script>
  </body>
</html>
