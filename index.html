<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <title>Galaxy Background</title>
    <!-- Import Three.js -->
    <script src="https://unpkg.com/three@0.152.0/build/three.min.js"></script>
    <style>
      /* On supprime les marges et le padding, et on définit un fond noir */
      body,
      html {
        margin: 0;
        padding: 0;
        background: #000;
        overflow: hidden;
      }
      /* Le canvas occupe tout l'écran */
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <!-- Le canvas qui servira pour le rendu Three.js -->
    <canvas id="threeCanvas"></canvas>
    <script>
      // Récupération du canvas dans lequel on va dessiner la scène
      const canvas = document.getElementById("threeCanvas");

      // Création du renderer (moteur de rendu WebGL)
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      // On insère le renderer dans le DOM en utilisant le canvas existant
      canvas.parentNode.insertBefore(renderer.domElement, canvas);

      // Création d'une scène Three.js, qui contiendra les objets 3D
      const scene = new THREE.Scene();

      // Création d'une caméra perspective
      // La caméra a un champ de vision de 75 degrés,
      // son aspect ratio est basé sur la taille de la fenêtre,
      // et elle affiche les objets situés entre 1 et 1000 unités de distance.
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        1,
        1000
      );
      // On positionne la caméra à une distance de 1 unité sur l'axe Z
      camera.position.z = 1;

      // Création d'un champ d'étoiles
      // On va créer 10 000 étoiles en générant leurs positions aléatoirement dans l'espace.
      const starCount = 10000;
      // Chaque étoile aura 3 coordonnées (x, y, z)
      const positions = new Float32Array(starCount * 3);
      for (let i = 0; i < starCount * 3; i++) {
        // Les positions sont réparties dans un volume de 2000 unités
        positions[i] = (Math.random() - 0.5) * 2000;
      }
      // On crée une BufferGeometry pour stocker les positions des étoiles
      const starGeometry = new THREE.BufferGeometry();
      starGeometry.setAttribute(
        "position",
        new THREE.BufferAttribute(positions, 3)
      );

      // Création d'un matériau pour les étoiles
      // Ici, PointsMaterial est utilisé pour dessiner des points.
      // On définit leur couleur blanche et leur taille à 1.2 unités.
      const starMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 1.2,
      });
      // Création d'un objet Points, qui affiche la géométrie avec le matériau défini
      const stars = new THREE.Points(starGeometry, starMaterial);
      // On ajoute le système d'étoiles à la scène
      scene.add(stars);

      // Fonction d'animation : on appelle cette fonction à chaque frame
      function animate() {
        requestAnimationFrame(animate);
        // Légère rotation des étoiles pour simuler un mouvement de galaxie
        stars.rotation.x += 0.0002;
        stars.rotation.y += 0.0004;
        // Rendu de la scène depuis la perspective de la caméra
        renderer.render(scene, camera);
      }
      // On démarre l'animation
      animate();

      // Adaptation du renderer et de la caméra lors du redimensionnement de la fenêtre
      window.addEventListener("resize", () => {
        const width = window.innerWidth;
        const height = window.innerHeight;
        renderer.setSize(width, height);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
      });
    </script>
  </body>
</html>
